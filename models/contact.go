// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Contact contact
//
// swagger:model Contact
type Contact struct {

	// Street or post box. Depending on the registry, up to 65,536 characters may be possible.
	Address []string `json:"address"`

	// A string that is either automatically generated when an alias is not sent or a self-defined string that can be set by the user for the purpose of identifying the domain contact.
	// Example: John-Doe-1
	Alias string `json:"alias,omitempty"`

	// The city of the contact
	// Example: Anytown
	City string `json:"city,omitempty"`

	// A freely definable text that can be set for a contact. May only be composed of ASCII characters.
	Comment string `json:"comment,omitempty"`

	// Confirmation of the domain holder that he agrees to the changes.
	//
	//  false or blank= Refuse confirmation. Order will not be accepted.
	//  true = Confirm
	//  default value = false
	//
	//  This confirmation has been required since December 7, 2016 due to ICANN's new change of ownership procedure for changes to the domain holder's name, email address or organization. Only for gTLDs and new gTLDs.
	ConfirmOwnerConsent bool `json:"confirmOwnerConsent,omitempty"`

	// Country (ISO 3166-1 alpha-2).
	//  Country Code.
	//  Certain strings, such as "Germany", are mapped to DE.
	// Example: DE
	Country string `json:"country,omitempty"`

	// Date of creation.
	// Format: date-time
	Created strfmt.DateTime `json:"created,omitempty"`

	// documents
	Documents []*ContactDocument `json:"documents"`

	// Indicates whether the domain contact is in the DomainSafe.
	Domainsafe bool `json:"domainsafe,omitempty"`

	// Email address
	// Example: john.doe@domain.com
	Email string `json:"email,omitempty"`

	// Additional data for contacts required by certain TLDs.
	Extensions *ContactExtensions `json:"extensions,omitempty"`

	// The fax number of the contact
	// Example: +49-123-12345
	Fax string `json:"fax,omitempty"`

	// First name
	// Example: John
	Fname string `json:"fname,omitempty"`

	// The unique identifier of the contact
	// Example: 1
	ID int32 `json:"id,omitempty"`

	// Last name
	// Example: Doe
	Lname string `json:"lname,omitempty"`

	// Manually create a NIC reference for the domain contact. This is not required, since the NIC references are always created automatically.
	//  This will no longer be supported in the future.
	NicRef []*ContactReference `json:"nicRef"`

	// The name of the organization
	// Example: Company
	Organization string `json:"organization,omitempty"`

	// The object owner.
	Owner *BasicUser `json:"owner,omitempty"`

	// The postal code (“zip-code”) of the contact. For countries Canada, Norway, Poland and Spain the format of the postal code is checked for validity.
	// Canada (ca): Six characters in the following format 'LNL NLN', where 'L' represents a letter and 'N' represents a number.
	// Norway (co): Four characters between 0001 and 9990.
	// Poland (pl): Consists of five digits, with a hyphen ('-') between the second and third digits.
	// Spain (es): Consisting of exactly five digits. No letters or special characters, only numbers. Each of the five positions can be any digit from 0 to 9.
	// Example: Canada: M5V 3H5, H3Z2Y7 \nNorway: 0010 \nPoland: 12-345 \nSpain: 28040
	Pcode string `json:"pcode,omitempty"`

	// The phone number of the contact
	// Example: +49-123-12345
	Phone string `json:"phone,omitempty"`

	// The protection of the contact
	Protection ContactProtectionConstants `json:"protection,omitempty"`

	// The sip of the contact
	Sip string `json:"sip,omitempty"`

	// The local country state of the contact
	// Example: BY
	State string `json:"state,omitempty"`

	// A prefix to a person’s name.
	// Example: Dr.
	Title string `json:"title,omitempty"`

	// Domain contact type
	Type ContactTypeConstants `json:"type,omitempty"`

	// Date of the last update.
	// Format: date-time
	Updated strfmt.DateTime `json:"updated,omitempty"`

	// User who performed the last update.
	Updater *BasicUser `json:"updater,omitempty"`

	// The status of domain contact verification.
	// Example: SUCCESS - Domain contact verification successful. \n PENDING - Domain contact verification in progress. \n FAILED - Domain contact verification failed. \n NOT_SET - Domain contact verification not started.
	Verification GenericStatusConstants `json:"verification,omitempty"`
}

// Validate validates this contact
func (m *Contact) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocuments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNicRef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdater(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Contact) validateCreated(formats strfmt.Registry) error {
	if swag.IsZero(m.Created) { // not required
		return nil
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Contact) validateDocuments(formats strfmt.Registry) error {
	if swag.IsZero(m.Documents) { // not required
		return nil
	}

	for i := 0; i < len(m.Documents); i++ {
		if swag.IsZero(m.Documents[i]) { // not required
			continue
		}

		if m.Documents[i] != nil {
			if err := m.Documents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("documents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("documents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Contact) validateExtensions(formats strfmt.Registry) error {
	if swag.IsZero(m.Extensions) { // not required
		return nil
	}

	if m.Extensions != nil {
		if err := m.Extensions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("extensions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("extensions")
			}
			return err
		}
	}

	return nil
}

func (m *Contact) validateNicRef(formats strfmt.Registry) error {
	if swag.IsZero(m.NicRef) { // not required
		return nil
	}

	for i := 0; i < len(m.NicRef); i++ {
		if swag.IsZero(m.NicRef[i]) { // not required
			continue
		}

		if m.NicRef[i] != nil {
			if err := m.NicRef[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nicRef" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nicRef" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Contact) validateOwner(formats strfmt.Registry) error {
	if swag.IsZero(m.Owner) { // not required
		return nil
	}

	if m.Owner != nil {
		if err := m.Owner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

func (m *Contact) validateProtection(formats strfmt.Registry) error {
	if swag.IsZero(m.Protection) { // not required
		return nil
	}

	if err := m.Protection.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("protection")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("protection")
		}
		return err
	}

	return nil
}

func (m *Contact) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := m.Type.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("type")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("type")
		}
		return err
	}

	return nil
}

func (m *Contact) validateUpdated(formats strfmt.Registry) error {
	if swag.IsZero(m.Updated) { // not required
		return nil
	}

	if err := validate.FormatOf("updated", "body", "date-time", m.Updated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Contact) validateUpdater(formats strfmt.Registry) error {
	if swag.IsZero(m.Updater) { // not required
		return nil
	}

	if m.Updater != nil {
		if err := m.Updater.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updater")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updater")
			}
			return err
		}
	}

	return nil
}

func (m *Contact) validateVerification(formats strfmt.Registry) error {
	if swag.IsZero(m.Verification) { // not required
		return nil
	}

	if err := m.Verification.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("verification")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("verification")
		}
		return err
	}

	return nil
}

// ContextValidate validate this contact based on the context it is used
func (m *Contact) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDocuments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtensions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNicRef(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOwner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProtection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdater(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVerification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Contact) contextValidateDocuments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Documents); i++ {

		if m.Documents[i] != nil {

			if swag.IsZero(m.Documents[i]) { // not required
				return nil
			}

			if err := m.Documents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("documents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("documents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Contact) contextValidateExtensions(ctx context.Context, formats strfmt.Registry) error {

	if m.Extensions != nil {

		if swag.IsZero(m.Extensions) { // not required
			return nil
		}

		if err := m.Extensions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("extensions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("extensions")
			}
			return err
		}
	}

	return nil
}

func (m *Contact) contextValidateNicRef(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NicRef); i++ {

		if m.NicRef[i] != nil {

			if swag.IsZero(m.NicRef[i]) { // not required
				return nil
			}

			if err := m.NicRef[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nicRef" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nicRef" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Contact) contextValidateOwner(ctx context.Context, formats strfmt.Registry) error {

	if m.Owner != nil {

		if swag.IsZero(m.Owner) { // not required
			return nil
		}

		if err := m.Owner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

func (m *Contact) contextValidateProtection(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Protection) { // not required
		return nil
	}

	if err := m.Protection.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("protection")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("protection")
		}
		return err
	}

	return nil
}

func (m *Contact) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := m.Type.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("type")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("type")
		}
		return err
	}

	return nil
}

func (m *Contact) contextValidateUpdater(ctx context.Context, formats strfmt.Registry) error {

	if m.Updater != nil {

		if swag.IsZero(m.Updater) { // not required
			return nil
		}

		if err := m.Updater.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updater")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updater")
			}
			return err
		}
	}

	return nil
}

func (m *Contact) contextValidateVerification(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Verification) { // not required
		return nil
	}

	if err := m.Verification.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("verification")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("verification")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Contact) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Contact) UnmarshalBinary(b []byte) error {
	var res Contact
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
