// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ZoneBasePatchRequest zone base patch request
//
// swagger:model ZoneBasePatchRequest
type ZoneBasePatchRequest struct {

	// Additional nameserver check is proceeded.
	Action NameserverActionConstants `json:"action,omitempty"`

	// Allow zone transfer for the defined zone grants
	AllowTransfer bool `json:"allowTransfer,omitempty"`

	// A custom field. Can only be updated via PUT /zone/{name}/{nameserver}/_comment. Requires appropriate ACLs.
	Comment string `json:"comment,omitempty"`

	// Date of creation.
	// Format: date-time
	Created strfmt.DateTime `json:"created,omitempty"`

	// Date of search.
	// Format: date-time
	Date strfmt.DateTime `json:"date,omitempty"`

	// If true dnssec signing for the zone is active.
	Dnssec bool `json:"dnssec,omitempty"`

	// Denotes of the zone is present in the DomainSafe service.
	Domainsafe bool `json:"domainsafe,omitempty"`

	// Freely definable resource records to be entered in BIND Syntax.
	FreeText []string `json:"freeText"`

	// A list of IP addresses from which a zone transfer (AXFR) by be started from for this zone.
	Grants []string `json:"grants"`

	// Punycode version of the origin.
	Idn string `json:"idn,omitempty"`

	// The id of the related log-entry.
	LogID int64 `json:"logId,omitempty"`

	// Main IP address of the zone. Required for ns_action "primary" and "complete".
	Main *MainIP `json:"main,omitempty"`

	// The modifer to apply on the objects
	Modifiers []*Modifier `json:"modifiers"`

	// Name of the nameserver group.
	NameServerGroup string `json:"nameServerGroup,omitempty"`

	// List of hostnames to be used as name severs.
	NameServers []*NameServer `json:"nameServers"`

	// Zone name
	Origin string `json:"origin,omitempty"`

	// Owner of the zone object
	Owner *BasicUser `json:"owner,omitempty"`

	// Date on which the zone is purged (removed) from the system.
	// Format: date-time
	PurgeDate strfmt.DateTime `json:"purgeDate,omitempty"`

	// Setting for automatic zone deletion.
	PurgeType PurgeTypes `json:"purgeType,omitempty"`

	// The resource records.
	ResourceRecords []*ResourceRecord `json:"resourceRecords"`

	// Adds new zone records to the extistings
	ResourceRecordsAdd []*ResourceRecord `json:"resourceRecordsAdd"`

	// Removes the zone records if exists.
	ResourceRecordsRem []*ResourceRecord `json:"resourceRecordsRem"`

	// The resource object identifier of the zone.
	// Example: 1
	Roid int32 `json:"roid,omitempty"`

	// Only for ns_action: "primary"  and "complete"
	Soa *Soa `json:"soa,omitempty"`

	// Name server from which a zone is copied via AXFR (with zone_import).
	Source string `json:"source,omitempty"`

	// System name server to look up the zone to copy
	SourceVirtualHostname string `json:"sourceVirtualHostname,omitempty"`

	// Date of the last update.
	// Format: date-time
	Updated strfmt.DateTime `json:"updated,omitempty"`

	// User who last updated the zone.
	Updater *BasicUser `json:"updater,omitempty"`

	// The first nameserver managed by the system
	VirtualNameServer string `json:"virtualNameServer,omitempty"`

	// Create a www A-record automatically?
	//
	// false = no
	// true = yes
	//
	//
	// Default = true
	//
	//
	// For XML, 0 (false) and 1 (true) can also be used.
	WwwInclude bool `json:"wwwInclude,omitempty"`

	// Adds new zone garnts to the zone
	ZoneGrantsAdd []string `json:"zoneGrantsAdd"`

	// Removes the zone garnts if exists.
	ZoneGrantsRem []string `json:"zoneGrantsRem"`
}

// Validate validates this zone base patch request
func (m *ZoneBasePatchRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNameServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurgeDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurgeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceRecords(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceRecordsAdd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceRecordsRem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoa(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdater(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZoneBasePatchRequest) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	if err := m.Action.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("action")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("action")
		}
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateCreated(formats strfmt.Registry) error {
	if swag.IsZero(m.Created) { // not required
		return nil
	}

	if err := validate.FormatOf("created", "body", "date-time", m.Created.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", m.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateMain(formats strfmt.Registry) error {
	if swag.IsZero(m.Main) { // not required
		return nil
	}

	if m.Main != nil {
		if err := m.Main.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("main")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("main")
			}
			return err
		}
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateModifiers(formats strfmt.Registry) error {
	if swag.IsZero(m.Modifiers) { // not required
		return nil
	}

	for i := 0; i < len(m.Modifiers); i++ {
		if swag.IsZero(m.Modifiers[i]) { // not required
			continue
		}

		if m.Modifiers[i] != nil {
			if err := m.Modifiers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("modifiers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("modifiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) validateNameServers(formats strfmt.Registry) error {
	if swag.IsZero(m.NameServers) { // not required
		return nil
	}

	for i := 0; i < len(m.NameServers); i++ {
		if swag.IsZero(m.NameServers[i]) { // not required
			continue
		}

		if m.NameServers[i] != nil {
			if err := m.NameServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nameServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nameServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) validateOwner(formats strfmt.Registry) error {
	if swag.IsZero(m.Owner) { // not required
		return nil
	}

	if m.Owner != nil {
		if err := m.Owner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

func (m *ZoneBasePatchRequest) validatePurgeDate(formats strfmt.Registry) error {
	if swag.IsZero(m.PurgeDate) { // not required
		return nil
	}

	if err := validate.FormatOf("purgeDate", "body", "date-time", m.PurgeDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) validatePurgeType(formats strfmt.Registry) error {
	if swag.IsZero(m.PurgeType) { // not required
		return nil
	}

	if err := m.PurgeType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("purgeType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("purgeType")
		}
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateResourceRecords(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceRecords) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceRecords); i++ {
		if swag.IsZero(m.ResourceRecords[i]) { // not required
			continue
		}

		if m.ResourceRecords[i] != nil {
			if err := m.ResourceRecords[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceRecords" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceRecords" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) validateResourceRecordsAdd(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceRecordsAdd) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceRecordsAdd); i++ {
		if swag.IsZero(m.ResourceRecordsAdd[i]) { // not required
			continue
		}

		if m.ResourceRecordsAdd[i] != nil {
			if err := m.ResourceRecordsAdd[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceRecordsAdd" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceRecordsAdd" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) validateResourceRecordsRem(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceRecordsRem) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceRecordsRem); i++ {
		if swag.IsZero(m.ResourceRecordsRem[i]) { // not required
			continue
		}

		if m.ResourceRecordsRem[i] != nil {
			if err := m.ResourceRecordsRem[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceRecordsRem" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceRecordsRem" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) validateSoa(formats strfmt.Registry) error {
	if swag.IsZero(m.Soa) { // not required
		return nil
	}

	if m.Soa != nil {
		if err := m.Soa.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("soa")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("soa")
			}
			return err
		}
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateUpdated(formats strfmt.Registry) error {
	if swag.IsZero(m.Updated) { // not required
		return nil
	}

	if err := validate.FormatOf("updated", "body", "date-time", m.Updated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) validateUpdater(formats strfmt.Registry) error {
	if swag.IsZero(m.Updater) { // not required
		return nil
	}

	if m.Updater != nil {
		if err := m.Updater.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updater")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updater")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this zone base patch request based on the context it is used
func (m *ZoneBasePatchRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNameServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOwner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePurgeType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceRecords(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceRecordsAdd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceRecordsRem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoa(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdater(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ZoneBasePatchRequest) contextValidateAction(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Action) { // not required
		return nil
	}

	if err := m.Action.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("action")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("action")
		}
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateMain(ctx context.Context, formats strfmt.Registry) error {

	if m.Main != nil {

		if swag.IsZero(m.Main) { // not required
			return nil
		}

		if err := m.Main.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("main")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("main")
			}
			return err
		}
	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateModifiers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Modifiers); i++ {

		if m.Modifiers[i] != nil {

			if swag.IsZero(m.Modifiers[i]) { // not required
				return nil
			}

			if err := m.Modifiers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("modifiers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("modifiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateNameServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NameServers); i++ {

		if m.NameServers[i] != nil {

			if swag.IsZero(m.NameServers[i]) { // not required
				return nil
			}

			if err := m.NameServers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nameServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nameServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateOwner(ctx context.Context, formats strfmt.Registry) error {

	if m.Owner != nil {

		if swag.IsZero(m.Owner) { // not required
			return nil
		}

		if err := m.Owner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidatePurgeType(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.PurgeType) { // not required
		return nil
	}

	if err := m.PurgeType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("purgeType")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("purgeType")
		}
		return err
	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateResourceRecords(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceRecords); i++ {

		if m.ResourceRecords[i] != nil {

			if swag.IsZero(m.ResourceRecords[i]) { // not required
				return nil
			}

			if err := m.ResourceRecords[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceRecords" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceRecords" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateResourceRecordsAdd(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceRecordsAdd); i++ {

		if m.ResourceRecordsAdd[i] != nil {

			if swag.IsZero(m.ResourceRecordsAdd[i]) { // not required
				return nil
			}

			if err := m.ResourceRecordsAdd[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceRecordsAdd" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceRecordsAdd" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateResourceRecordsRem(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceRecordsRem); i++ {

		if m.ResourceRecordsRem[i] != nil {

			if swag.IsZero(m.ResourceRecordsRem[i]) { // not required
				return nil
			}

			if err := m.ResourceRecordsRem[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceRecordsRem" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceRecordsRem" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateSoa(ctx context.Context, formats strfmt.Registry) error {

	if m.Soa != nil {

		if swag.IsZero(m.Soa) { // not required
			return nil
		}

		if err := m.Soa.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("soa")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("soa")
			}
			return err
		}
	}

	return nil
}

func (m *ZoneBasePatchRequest) contextValidateUpdater(ctx context.Context, formats strfmt.Registry) error {

	if m.Updater != nil {

		if swag.IsZero(m.Updater) { // not required
			return nil
		}

		if err := m.Updater.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updater")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updater")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ZoneBasePatchRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ZoneBasePatchRequest) UnmarshalBinary(b []byte) error {
	var res ZoneBasePatchRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
